import prisma from '../../config/prisma.js';
import { Prisma } from '@prisma/client';
import { extract_zip_file, cleanup_temp_files, type PassengerFolder } from '../../utils/zip_extractor.js';
import { get_file_path, delete_file } from '../../utils/file_upload.js';
import ocr_service from '../ocr/ocr.service.js';
import logger from '../../utils/logger.js';
import * as path from 'path';
import * as fs from 'fs';
// UUID is generated by Prisma, no need to import

export interface CreateOrderInput {
  partner_account_id: string; // Use partner_account_id instead of partner_id
  visa_type_id: string;
  country_id: string;
  order_type: 'INDIVIDUAL' | 'GROUP';
  group_name?: string | undefined;
  travel_dates?: string | undefined; // JSON string or comma-separated dates
  zip_file_path?: string | undefined; // Path to uploaded zip file (for group orders)
  // For individual orders
  traveller_name?: string | undefined;
  traveller_files?: Array<{ filename: string; file_path: string; file_type: string }> | undefined;
}

export interface OrderResponse {
  id: string;
  order_id: string;
  partner_id: string;
  visa_type_id: string;
  country_id: string;
  order_type: string;
  status: string;
  group_name: string | null;
  travel_dates: string | null;
  total_fee_amount: number | null;
  fee_currency: string | null;
  travellers_count: number;
  documents_count: number;
  created_at: Date;
}

class OrderService {
  async createOrder(input: CreateOrderInput): Promise<OrderResponse> {
    try {
      // Validate required fields
      if (!input.partner_account_id || !input.visa_type_id || !input.country_id || !input.order_type) {
        throw new Error('partner_account_id, visa_type_id, country_id, and order_type are required');
      }

      // Get partner account by partner_account_id
      const partner_account = await prisma.partnerAccount.findFirst({
        where: { partner_account_id: input.partner_account_id },
      });

      if (!partner_account) {
        throw new Error(`Partner account with id '${input.partner_account_id}' not found`);
      }

      const partner_id = partner_account.id;

      // Validate order type specific requirements
      if (input.order_type === 'GROUP') {
        if (!input.group_name) {
          throw new Error('group_name is required for GROUP orders');
        }
        if (!input.zip_file_path) {
          throw new Error('zip_file_path is required for GROUP orders');
        }
      } else if (input.order_type === 'INDIVIDUAL') {
        if (!input.traveller_name) {
          throw new Error('traveller_name is required for INDIVIDUAL orders');
        }
      }

      // Verify country exists using country_id (UUID field)
      const country = await prisma.country.findFirst({
        where: {
          country_id: input.country_id,
        },
      });

      if (!country) {
        throw new Error(`Country with country_id '${input.country_id}' not found`);
      }

      // Verify visa type exists using visa_type_id (UUID field)
      const visa_type = await prisma.visaType.findFirst({
        where: {
          visa_type_id: input.visa_type_id,
        },
        include: {
          country: true,
          visa_fees: {
            where: {
              OR: [
                { valid_to: null },
                { valid_to: { gte: new Date() } },
              ],
            },
            orderBy: {
              base_fee_amount: 'asc',
            },
            take: 1,
          },
        },
      });

      if (!visa_type) {
        throw new Error(`Visa type with visa_type_id '${input.visa_type_id}' not found`);
      }

      // Verify visa type belongs to the country (compare using country's primary id)
      if (visa_type.country_id !== country.id) {
        throw new Error('Country ID does not match visa type country');
      }

      // Calculate total fee
      const fee = visa_type.visa_fees[0];
      const total_fee_amount = fee ? fee.base_fee_amount + (fee.service_fee_amount || 0) + (fee.tax_amount || 0) : null;
      const fee_currency = fee?.currency || null;

      // Get required documents for this visa type (use visa type's primary id)
      const required_documents = await prisma.visaRequiredDocument.findMany({
        where: {
          visa_type_id: visa_type.id, // Use visa type's primary id for foreign key
        },
      });

      // Use transaction for all operations
      const result = await prisma.$transaction(async (tx) => {
        // Create order (use primary ids for foreign keys)
        const order = await tx.order.create({
          data: {
            partner_id: partner_id,
            visa_type_id: visa_type.id, // Use visa type's primary id for foreign key
            country_id: country.id, // Use country's primary id for foreign key
            order_type: input.order_type,
            status: 'DOCUMENT_PENDING',
            total_fee_amount,
            fee_currency,
            group_name: input.group_name || null,
            travel_dates: input.travel_dates || null,
          },
        });

        let passengers: PassengerFolder[] = [];

        // Handle GROUP order - extract zip file
        if (input.order_type === 'GROUP' && input.zip_file_path) {
          try {
            passengers = await extract_zip_file(input.zip_file_path);
            
            if (passengers.length === 0) {
              throw new Error('No passenger folders found in zip file');
            }
          } catch (error) {
            throw new Error(`Failed to process zip file: ${error instanceof Error ? error.message : 'Unknown error'}`);
          }
        } else if (input.order_type === 'INDIVIDUAL' && input.traveller_name && input.traveller_files) {
          // Handle INDIVIDUAL order
          passengers = [{
            passenger_name: input.traveller_name,
            files: input.traveller_files,
          }];
        }

        // Create travellers and documents
        const travellers_created = [];
        let primary_index = 0;

        for (let i = 0; i < passengers.length; i++) {
          const passenger = passengers[i];
          if (!passenger || !passenger.passenger_name) continue;
          
          const is_primary = i === primary_index;

          // Create traveller
          const traveller = await tx.orderTraveller.create({
            data: {
              order_id: order.id,
              is_primary_applicant: is_primary,
              full_name: passenger.passenger_name,
              date_of_birth: null,
              nationality_id: null,
              passport_number: null,
              passport_issue_date: null,
              passport_expiry_date: null,
              email: null,
              phone: null,
            },
          });

          travellers_created.push(traveller);

          // Process files for this traveller
          if (!passenger.files || passenger.files.length === 0) continue;
          
          for (const file of passenger.files) {
            // Try to match file to required document by name/type
            let matched_document = required_documents.find(doc => {
              const doc_name_lower = doc.document_name.toLowerCase();
              const file_type_lower = file.file_type.toLowerCase();
              const filename_lower = file.filename.toLowerCase();

              return doc_name_lower.includes(file_type_lower) ||
                     filename_lower.includes(doc_name_lower) ||
                     doc.document_code.toLowerCase().includes(file_type_lower);
            });

            // If no match found, use first required document or create a generic one
            if (!matched_document && required_documents.length > 0) {
              matched_document = required_documents[0];
            }

            if (matched_document) {
              // Move file to permanent storage
              const uploads_dir = path.join(process.cwd(), 'uploads', 'orders', order.order_id);
              if (!fs.existsSync(uploads_dir)) {
                fs.mkdirSync(uploads_dir, { recursive: true });
              }

              const file_ext = path.extname(file.filename);
              const new_filename = `${traveller.order_traveller_id}-${matched_document.document_code}-${Date.now()}${file_ext}`;
              const permanent_path = path.join(uploads_dir, new_filename);

              // Copy file to permanent location
              if (fs.existsSync(file.file_path)) {
                fs.copyFileSync(file.file_path, permanent_path);
              }

              const file_url = `/uploads/orders/${order.order_id}/${new_filename}`;

              // Create document record
              const document = await tx.orderTravellerDocument.create({
                data: {
                  order_id: order.id,
                  traveller_id: traveller.id,
                  required_document_id: matched_document.id,
                  file_url: file_url,
                  verification_status: null,
                  verification_notes: null,
                  verified_at: null,
                  ocr_status: null,
                  ocr_job_id: null,
                  ocr_extracted_data: Prisma.JsonNull,
                },
              });

              // Trigger OCR for passport documents (async, don't block)
              const filename_lower = file.filename.toLowerCase();
              if (file.file_type === 'passport' || filename_lower.includes('passport')) {
                // Submit to OCR service asynchronously (don't await, fire and forget)
                setImmediate(async () => {
                  try {
                    // First update status to PENDING
                    await prisma.orderTravellerDocument.update({
                      where: { id: document.id },
                      data: {
                        ocr_status: 'PENDING',
                      },
                    });

                    const ocr_result = await ocr_service.submit_passport_for_ocr({
                      order_id: order.order_id,
                      traveller_id: traveller.order_traveller_id,
                      document_id: document.order_traveller_document_id,
                      file_path: permanent_path,
                    });

                    // Update document with OCR job ID and status
                    await prisma.orderTravellerDocument.update({
                      where: { id: document.id },
                      data: {
                        ocr_job_id: ocr_result.job_id,
                        ocr_status: 'PROCESSING',
                      },
                    });

                    logger.info(`OCR job ${ocr_result.job_id} submitted for document ${document.order_traveller_document_id}`);
                  } catch (error) {
                    logger.error(`Failed to submit OCR for document ${document.order_traveller_document_id}:`, error);
                    // Update status to FAILED
                    try {
                      await prisma.orderTravellerDocument.update({
                        where: { id: document.id },
                        data: {
                          ocr_status: 'FAILED',
                        },
                      });
                    } catch (update_error) {
                      logger.error('Failed to update OCR status:', update_error);
                    }
                  }
                });
              }
            }
          }
        }

        // Clean up temporary files
        if (input.order_type === 'GROUP' && passengers.length > 0) {
          await cleanup_temp_files(passengers);
        }

        // Clean up uploaded zip file
        if (input.zip_file_path) {
          await delete_file(input.zip_file_path);
        }

        // Get counts
        const travellers_count = await tx.orderTraveller.count({
          where: { order_id: order.id },
        });

        const documents_count = await tx.orderTravellerDocument.count({
          where: { order_id: order.id },
        });

        // Get country and visa type to return UUIDs in response
        const order_country = await tx.country.findUnique({
          where: { id: order.country_id },
          select: { country_id: true },
        });

        const order_visa_type = await tx.visaType.findUnique({
          where: { id: order.visa_type_id },
          select: { visa_type_id: true },
        });

        return {
          id: order.id,
          order_id: order.order_id,
          partner_id: order.partner_id,
          visa_type_id: order_visa_type?.visa_type_id || input.visa_type_id, // Return UUID visa_type_id
          country_id: order_country?.country_id || input.country_id, // Return UUID country_id
          order_type: order.order_type,
          status: order.status,
          group_name: order.group_name,
          travel_dates: order.travel_dates,
          total_fee_amount: order.total_fee_amount,
          fee_currency: order.fee_currency,
          travellers_count,
          documents_count,
          created_at: order.created_at,
        };
      });

      return result;
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      throw new Error(`Failed to create order: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
}

export default new OrderService();

