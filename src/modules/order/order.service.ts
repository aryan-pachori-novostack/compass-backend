import prisma from '../../config/prisma.js';
import { Prisma } from '@prisma/client';
import { extract_zip_file, cleanup_temp_files, type PassengerFolder } from '../../utils/zip_extractor.js';
import { get_file_path, delete_file } from '../../utils/file_upload.js';
import { upload_to_s3 } from '../../utils/s3.js';
import { env } from '../../config/env.js';
import logger from '../../utils/logger.js';
import * as path from 'path';
import * as fs from 'fs';
// UUID is generated by Prisma, no need to import

export interface CreateOrderInput {
  partner_account_id: string; // Use partner_account_id instead of partner_id
  visa_type_id: string;
  country_id: string;
  order_type: 'INDIVIDUAL' | 'GROUP';
  group_name?: string | undefined;
  travel_dates?: string | undefined; // JSON string or comma-separated dates
  zip_file_path?: string | undefined; // Path to uploaded zip file (for group orders)
  // For individual orders
  traveller_name?: string | undefined;
  traveller_files?: Array<{ filename: string; file_path: string; file_type: string }> | undefined;
}

export interface OrderResponse {
  id: string;
  order_id: string;
  partner_id: string;
  visa_type_id: string;
  country_id: string;
  order_type: string;
  status: string;
  group_name: string | null;
  travel_dates: string | null;
  total_fee_amount: number | null;
  fee_currency: string | null;
  travellers_count: number;
  documents_count: number;
  created_at: Date;
}

class OrderService {
  async createOrder(input: CreateOrderInput): Promise<OrderResponse> {
    try {
      // Validate required fields
      if (!input.partner_account_id || !input.visa_type_id || !input.country_id || !input.order_type) {
        throw new Error('partner_account_id, visa_type_id, country_id, and order_type are required');
      }

      // Get partner account by partner_account_id
      const partner_account = await prisma.partnerAccount.findFirst({
        where: { partner_account_id: input.partner_account_id },
      });

      if (!partner_account) {
        throw new Error(`Partner account with id '${input.partner_account_id}' not found`);
      }

      const partner_id = partner_account.id;

      // Validate order type specific requirements
      if (input.order_type === 'GROUP') {
        if (!input.group_name) {
          throw new Error('group_name is required for GROUP orders');
        }
        if (!input.zip_file_path) {
          throw new Error('zip_file_path is required for GROUP orders');
        }
      } else if (input.order_type === 'INDIVIDUAL') {
        if (!input.traveller_name) {
          throw new Error('traveller_name is required for INDIVIDUAL orders');
        }
      }

      // Verify country exists using country_id (UUID field)
      const country = await prisma.country.findFirst({
        where: {
          country_id: input.country_id,
        },
      });

      if (!country) {
        throw new Error(`Country with country_id '${input.country_id}' not found`);
      }

      // Verify visa type exists using visa_type_id (UUID field)
      const visa_type = await prisma.visaType.findFirst({
        where: {
          visa_type_id: input.visa_type_id,
        },
        include: {
          country: true,
          visa_fees: {
            where: {
              OR: [
                { valid_to: null },
                { valid_to: { gte: new Date() } },
              ],
            },
            orderBy: {
              base_fee_amount: 'asc',
            },
            take: 1,
          },
        },
      });

      if (!visa_type) {
        throw new Error(`Visa type with visa_type_id '${input.visa_type_id}' not found`);
      }

      // Verify visa type belongs to the country (compare using country's primary id)
      if (visa_type.country_id !== country.id) {
        throw new Error('Country ID does not match visa type country');
      }

      // Calculate total fee
      const fee = visa_type.visa_fees[0];
      const total_fee_amount = fee ? fee.base_fee_amount + (fee.service_fee_amount || 0) + (fee.tax_amount || 0) : null;
      const fee_currency = fee?.currency || null;

      // Get required documents for this visa type (use visa type's primary id)
      const required_documents = await prisma.visaRequiredDocument.findMany({
        where: {
          visa_type_id: visa_type.id, // Use visa type's primary id for foreign key
        },
      });

      // Use transaction for all operations
      const result = await prisma.$transaction(async (tx) => {
        // Create order (use primary ids for foreign keys)
        const order = await tx.order.create({
          data: {
            partner_id: partner_id,
            visa_type_id: visa_type.id, // Use visa type's primary id for foreign key
            country_id: country.id, // Use country's primary id for foreign key
            order_type: input.order_type,
            status: 'DOCUMENT_PENDING',
            total_fee_amount,
            fee_currency,
            group_name: input.group_name || null,
            travel_dates: input.travel_dates || null,
          },
        });

        let passengers: PassengerFolder[] = [];

        // Handle GROUP order - extract zip file
        if (input.order_type === 'GROUP' && input.zip_file_path) {
          try {
            passengers = await extract_zip_file(input.zip_file_path);
            
            logger.debug(`Extracted ${passengers.length} passengers from zip file`);
            passengers.forEach((p, i) => {
              logger.debug(`Passenger ${i + 1}: ${p.passenger_name} with ${p.files.length} files`);
            });
            
            if (passengers.length === 0) {
              throw new Error('No passenger folders found in zip file');
            }
          } catch (error) {
            logger.error('Failed to extract zip file:', error);
            throw new Error(`Failed to process zip file: ${error instanceof Error ? error.message : 'Unknown error'}`);
          }
        } else if (input.order_type === 'INDIVIDUAL' && input.traveller_name && input.traveller_files) {
          // Handle INDIVIDUAL order
          passengers = [{
            passenger_name: input.traveller_name,
            files: input.traveller_files,
          }];
        }

        // Create travellers and documents
        const travellers_created = [];
        let primary_index = 0;

        for (let i = 0; i < passengers.length; i++) {
          const passenger = passengers[i];
          if (!passenger || !passenger.passenger_name) continue;
          
          const is_primary = i === primary_index;

          // Create traveller
          const traveller = await tx.orderTraveller.create({
            data: {
              order_id: order.id,
              is_primary_applicant: is_primary,
              full_name: passenger.passenger_name,
              date_of_birth: null,
              nationality_id: null,
              passport_number: null,
              passport_issue_date: null,
              passport_expiry_date: null,
              email: null,
              phone: null,
            },
          });

          travellers_created.push(traveller);

          // Process files for this traveller
          if (!passenger.files || passenger.files.length === 0) continue;
          
          for (const file of passenger.files) {
            // Try to match file to required document by name/type
            let matched_document = required_documents.find(doc => {
              const doc_name_lower = doc.document_name.toLowerCase();
              const file_type_lower = file.file_type.toLowerCase();
              const filename_lower = file.filename.toLowerCase();

              return doc_name_lower.includes(file_type_lower) ||
                     filename_lower.includes(doc_name_lower) ||
                     doc.document_code.toLowerCase().includes(file_type_lower);
            });

            // If no match found, use first required document or create a generic one
            if (!matched_document && required_documents.length > 0) {
              matched_document = required_documents[0];
            }

            if (matched_document) {
              // Only upload passport (front/back), hotel, and flight tickets to S3
              // Other documents (photos, etc.) go to local storage
              const file_ext = path.extname(file.filename);
              let file_url: string = '';
              
              const should_upload_to_s3 = 
                file.file_type === 'passport_front' || 
                file.file_type === 'passport_back' || 
                file.file_type === 'hotel' || 
                file.file_type === 'flight';
              
              // Check if S3 is configured
              const has_access_key = env.s3.access_key_id && env.s3.access_key_id.trim().length > 0;
              const has_secret_key = env.s3.secret_access_key && env.s3.secret_access_key.trim().length > 0;
              const has_bucket = env.s3.bucket_name && env.s3.bucket_name.trim().length > 0;
              const use_s3 = has_access_key && has_secret_key && has_bucket && should_upload_to_s3;
              
              logger.debug(`File type: ${file.file_type}, Upload to S3: ${use_s3}`);
              
              if (use_s3) {
                // Upload passport/hotel/flight to S3
                const s3_key = `orders/${order.order_id}/travellers/${traveller.order_traveller_id}/${file.file_type}/${Date.now()}-${file.filename}`;
                
                // Determine content type
                const ext = file_ext.slice(1).toLowerCase();
                let content_type = 'application/octet-stream';
                if (['jpg', 'jpeg'].includes(ext)) content_type = 'image/jpeg';
                else if (ext === 'png') content_type = 'image/png';
                else if (ext === 'pdf') content_type = 'application/pdf';
                
                try {
                  const upload_result = await upload_to_s3({
                    file_path: file.file_path,
                    s3_key: s3_key,
                    content_type: content_type,
                    metadata: {
                      order_id: order.order_id,
                      traveller_id: traveller.order_traveller_id,
                      document_type: file.file_type,
                      original_filename: file.filename,
                    },
                  });
                  file_url = upload_result.s3_url;
                  logger.debug(`Uploaded ${file.file_type} to S3: ${file_url}`);
                } catch (error) {
                  logger.warn(`S3 upload failed for ${file.file_type}, using local storage: ${error instanceof Error ? error.message : 'Unknown error'}`);
                  // Will fallback to local storage below
                }
              }
              
              // Use local storage for non-S3 documents or if S3 upload failed
              if (!file_url || file_url === '') {
                const uploads_dir = path.join(process.cwd(), 'uploads', 'orders', order.order_id);
                if (!fs.existsSync(uploads_dir)) {
                  fs.mkdirSync(uploads_dir, { recursive: true });
                }

                const new_filename = `${traveller.order_traveller_id}-${matched_document.document_code}-${Date.now()}${file_ext}`;
                const permanent_path = path.join(uploads_dir, new_filename);

                // Copy file to permanent location
                if (fs.existsSync(file.file_path)) {
                  fs.copyFileSync(file.file_path, permanent_path);
                }

                file_url = `/uploads/orders/${order.order_id}/${new_filename}`;
                logger.debug(`Stored ${file.file_type} locally: ${file_url}`);
              }

              // Create document record
              const document = await tx.orderTravellerDocument.create({
                data: {
                  order_id: order.id,
                  traveller_id: traveller.id,
                  required_document_id: matched_document.id,
                  file_url: file_url,
                  verification_status: null,
                  verification_notes: null,
                  verified_at: null,
                  ocr_status: 'PENDING',
                  ocr_job_id: null,
                  ocr_extracted_data: Prisma.JsonNull,
                },
              });
            }
          }
        }

        // Clean up temporary files
        if (input.order_type === 'GROUP' && passengers.length > 0) {
          await cleanup_temp_files(passengers);
        }

        // Clean up uploaded zip file
        if (input.zip_file_path) {
          await delete_file(input.zip_file_path);
        }

        // Get counts
        const travellers_count = await tx.orderTraveller.count({
          where: { order_id: order.id },
        });

        const documents_count = await tx.orderTravellerDocument.count({
          where: { order_id: order.id },
        });

        // Get country and visa type to return UUIDs in response
        const order_country = await tx.country.findUnique({
          where: { id: order.country_id },
          select: { country_id: true },
        });

        const order_visa_type = await tx.visaType.findUnique({
          where: { id: order.visa_type_id },
          select: { visa_type_id: true },
        });

        return {
          id: order.id,
          order_id: order.order_id,
          partner_id: order.partner_id,
          visa_type_id: order_visa_type?.visa_type_id || input.visa_type_id, // Return UUID visa_type_id
          country_id: order_country?.country_id || input.country_id, // Return UUID country_id
          order_type: order.order_type,
          status: order.status,
          group_name: order.group_name,
          travel_dates: order.travel_dates,
          total_fee_amount: order.total_fee_amount,
          fee_currency: order.fee_currency,
          travellers_count,
          documents_count,
          created_at: order.created_at,
        };
      });

      // Send documents to OCR microservice asynchronously (fire and forget)
      // OCR service will:
      // 1. Download files from pre-signed URLs
      // 2. Process OCR
      // 3. Update database with OCR results
      // 4. Send SSE events via Redis
      setImmediate(async () => {
        try {
          await this.send_documents_to_ocr_service(result.order_id);
        } catch (error) {
          logger.error(`Failed to send documents to OCR service for order ${result.order_id}:`, error);
        }
      });

      return result;
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      throw new Error(`Failed to create order: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Send documents to OCR microservice for processing
   * Main backend uploads passport/hotel/flight to S3, then sends pre-signed URLs to OCR service
   */
  private async send_documents_to_ocr_service(order_id: string): Promise<void> {
    try {
      // Find order by order_id (business ID)
      const order = await prisma.order.findFirst({
        where: { order_id },
        select: { id: true },
      });

      if (!order) {
        logger.warn(`Order not found: ${order_id}`);
        return;
      }

      // Get all documents for this order (only passport/hotel/flight should be in S3)
      const documents = await prisma.orderTravellerDocument.findMany({
        where: {
          order_id: order.id,
          file_url: {
            startsWith: 's3://', // Only send S3 documents to OCR service
          },
        },
        include: {
          traveller: {
            select: {
              order_traveller_id: true,
              full_name: true,
            },
          },
        },
      });

      if (documents.length === 0) {
        logger.warn(`No S3 documents found for order ${order_id} to send to OCR service`);
        return;
      }

      // Generate pre-signed URLs for S3 files so OCR service doesn't need S3 credentials
      const { get_signed_url, extract_s3_key_from_url } = await import('../../utils/s3.js');
      
      const documents_payload = await Promise.all(documents.map(async (doc) => {
        // Extract document type from S3 key path (format: orders/{order_id}/travellers/{traveller_id}/{document_type}/{filename})
        const s3_key = extract_s3_key_from_url(doc.file_url) || '';
        const path_parts = s3_key.split('/');
        // Document type is at index 4 (after orders, order_id, travellers, traveller_id)
        const doc_type_from_path = path_parts.length >= 5 ? path_parts[4] : 'other';
        
        // Generate pre-signed URL for S3 files (valid for 1 hour)
        let file_url = doc.file_url;
        if (doc.file_url && doc.file_url.startsWith('s3://')) {
          try {
            const s3_key_for_signing = extract_s3_key_from_url(doc.file_url);
            if (s3_key_for_signing) {
              file_url = await get_signed_url(s3_key_for_signing, 3600);
              logger.debug(`Generated pre-signed URL for document ${doc.order_traveller_document_id}`);
            } else {
              logger.warn(`Could not extract S3 key from URL: ${doc.file_url}`);
            }
          } catch (error) {
            logger.error(`Failed to generate pre-signed URL for ${doc.file_url}:`, error);
            throw new Error(`Failed to generate pre-signed URL for document ${doc.order_traveller_document_id}: ${error instanceof Error ? error.message : 'Unknown error'}`);
          }
        }
        
        return {
          traveller_id: doc.traveller?.order_traveller_id || '',
          traveller_name: doc.traveller?.full_name || '',
          document_id: doc.order_traveller_document_id,
          file_url: file_url, // Pre-signed URL
          document_type: this.determine_document_type(doc.file_url || '', doc_type_from_path),
        };
      }));

      // Send to OCR microservice
      const ocr_service_url = env.ocr.service_url || 'http://localhost:8001';
      
      // Only call OCR service if URL is configured (not empty)
      if (!ocr_service_url || ocr_service_url.trim() === '') {
        logger.info(`Skipping OCR service call for order ${order_id} (OCR service URL not configured)`);
        return;
      }
      
      logger.info(`Sending ${documents_payload.length} documents to OCR microservice for order ${order_id}`);
      
      const response = await fetch(`${ocr_service_url}/process/documents`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          order_id,
          documents: documents_payload,
        }),
      });

      if (!response.ok) {
        const error_text = await response.text();
        throw new Error(`OCR microservice error: ${response.status} - ${error_text}`);
      }

      logger.info(`âœ… Documents sent to OCR microservice for order ${order_id}`);
    } catch (error) {
      logger.error(`Failed to send documents to OCR service:`, error);
      throw error;
    }
  }

  /**
   * Determine document type from file URL or other metadata
   */
  private determine_document_type(file_url: string, file_type?: string): string {
    // Use file_type from zip extractor if available
    if (file_type) {
      return file_type;
    }
    
    const url_lower = file_url.toLowerCase();
    const filename = url_lower.split('/').pop() || '';
    
    // Check for passport files (front/back)
    if (filename.includes('ppf') || filename.includes('passport_front') || (filename.includes('passport') && filename.includes('front'))) {
      return 'passport_front';
    }
    if (filename.includes('ppb') || filename.includes('passport_back') || (filename.includes('passport') && filename.includes('back'))) {
      return 'passport_back';
    }
    if (filename.includes('passport')) {
      return 'passport';
    }
    
    // Check for flight tickets
    if (filename.includes('ticket') || filename.includes('flight')) {
      return 'flight';
    }
    
    // Check for hotel
    if (filename.includes('hotel')) {
      return 'hotel';
    }
    
    // Check path for document type (S3 paths: orders/{order_id}/travellers/{traveller_id}/{document_type}/...)
    // Path structure: [0]=orders, [1]=order_id, [2]=travellers, [3]=traveller_id, [4]=document_type, [5]=filename
    const path_parts = url_lower.split('/');
    const travellers_index = path_parts.findIndex(p => p === 'travellers');
    if (travellers_index >= 0 && path_parts.length > travellers_index + 2) {
      // Document type is 2 positions after 'travellers' (skip traveller_id)
      const doc_type = path_parts[travellers_index + 2];
      if (doc_type && ['passport_front', 'passport_back', 'passport', 'flight', 'hotel', 'photo', 'visa'].includes(doc_type)) {
        return doc_type;
      }
    }
    
    return 'other';
  }
}

export default new OrderService();

