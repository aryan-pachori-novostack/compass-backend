import prisma from '../../config/prisma.js';
import { Prisma } from '@prisma/client';
import { extract_zip_file, cleanup_temp_files, type PassengerFolder } from '../../utils/zip_extractor.js';
import { get_file_path, delete_file } from '../../utils/file_upload.js';
import { upload_to_s3 } from '../../utils/s3.js';
import { env } from '../../config/env.js';
import logger from '../../utils/logger.js';
import * as path from 'path';
import * as fs from 'fs';
// UUID is generated by Prisma, no need to import

export interface CreateOrderInput {
  partner_account_id: string; // Use partner_account_id instead of partner_id
  visa_type_id: string;
  country_id: string;
  order_type: 'INDIVIDUAL' | 'GROUP';
  group_name?: string | undefined;
  travel_dates?: string | undefined; // JSON string or comma-separated dates
  zip_file_path?: string | undefined; // Path to uploaded zip file (for group orders)
  // For individual orders
  traveller_name?: string | undefined;
  traveller_files?: Array<{ filename: string; file_path: string; file_type: string }> | undefined;
}

export interface OrderResponse {
  id: string;
  order_id: string;
  partner_id: string;
  visa_type_id: string;
  country_id: string;
  order_type: string;
  status: string;
  group_name: string | null;
  travel_dates: string | null;
  total_fee_amount: number | null;
  fee_currency: string | null;
  travellers_count: number;
  documents_count: number;
  created_at: Date;
}

class OrderService {
  async createOrder(input: CreateOrderInput): Promise<OrderResponse> {
    try {
      // Validate required fields
      if (!input.partner_account_id || !input.visa_type_id || !input.country_id || !input.order_type) {
        throw new Error('partner_account_id, visa_type_id, country_id, and order_type are required');
      }

      // Get partner account by partner_account_id
      const partner_account = await prisma.partnerAccount.findFirst({
        where: { partner_account_id: input.partner_account_id },
      });

      if (!partner_account) {
        throw new Error(`Partner account with id '${input.partner_account_id}' not found`);
      }

      const partner_id = partner_account.id;

      // Validate order type specific requirements
      if (input.order_type === 'GROUP') {
        if (!input.group_name) {
          throw new Error('group_name is required for GROUP orders');
        }
        if (!input.zip_file_path) {
          throw new Error('zip_file_path is required for GROUP orders');
        }
      } else if (input.order_type === 'INDIVIDUAL') {
        if (!input.traveller_name) {
          throw new Error('traveller_name is required for INDIVIDUAL orders');
        }
      }

      // Verify country exists using country_id (UUID field)
      const country = await prisma.country.findFirst({
        where: {
          country_id: input.country_id,
        },
      });

      if (!country) {
        throw new Error(`Country with country_id '${input.country_id}' not found`);
      }

      // Verify visa type exists using visa_type_id (UUID field)
      const visa_type = await prisma.visaType.findFirst({
        where: {
          visa_type_id: input.visa_type_id,
        },
        include: {
          country: true,
          visa_fees: {
            where: {
              OR: [
                { valid_to: null },
                { valid_to: { gte: new Date() } },
              ],
            },
            orderBy: {
              base_fee_amount: 'asc',
            },
            take: 1,
          },
        },
      });

      if (!visa_type) {
        throw new Error(`Visa type with visa_type_id '${input.visa_type_id}' not found`);
      }

      // Verify visa type belongs to the country (compare using country's primary id)
      if (visa_type.country_id !== country.id) {
        throw new Error('Country ID does not match visa type country');
      }

      // Calculate total fee
      const fee = visa_type.visa_fees[0];
      const total_fee_amount = fee ? fee.base_fee_amount + (fee.service_fee_amount || 0) + (fee.tax_amount || 0) : null;
      const fee_currency = fee?.currency || null;

      // Get required documents for this visa type (use visa type's primary id)
      const required_documents = await prisma.visaRequiredDocument.findMany({
        where: {
          visa_type_id: visa_type.id, // Use visa type's primary id for foreign key
        },
      });

      // Use transaction for all operations
      const result = await prisma.$transaction(async (tx) => {
        // Create order (use primary ids for foreign keys)
        const order = await tx.order.create({
          data: {
            partner_id: partner_id,
            visa_type_id: visa_type.id, // Use visa type's primary id for foreign key
            country_id: country.id, // Use country's primary id for foreign key
            order_type: input.order_type,
            status: 'DOCUMENT_PENDING',
            total_fee_amount,
            fee_currency,
            group_name: input.group_name || null,
            travel_dates: input.travel_dates || null,
          },
        });

        let passengers: PassengerFolder[] = [];

        // Handle GROUP order - extract zip file
        if (input.order_type === 'GROUP' && input.zip_file_path) {
          try {
            passengers = await extract_zip_file(input.zip_file_path);
            
            if (passengers.length === 0) {
              throw new Error('No passenger folders found in zip file');
            }
          } catch (error) {
            throw new Error(`Failed to process zip file: ${error instanceof Error ? error.message : 'Unknown error'}`);
          }
        } else if (input.order_type === 'INDIVIDUAL' && input.traveller_name && input.traveller_files) {
          // Handle INDIVIDUAL order
          passengers = [{
            passenger_name: input.traveller_name,
            files: input.traveller_files,
          }];
        }

        // Create travellers and documents
        const travellers_created = [];
        let primary_index = 0;

        for (let i = 0; i < passengers.length; i++) {
          const passenger = passengers[i];
          if (!passenger || !passenger.passenger_name) continue;
          
          const is_primary = i === primary_index;

          // Create traveller
          const traveller = await tx.orderTraveller.create({
            data: {
              order_id: order.id,
              is_primary_applicant: is_primary,
              full_name: passenger.passenger_name,
              date_of_birth: null,
              nationality_id: null,
              passport_number: null,
              passport_issue_date: null,
              passport_expiry_date: null,
              email: null,
              phone: null,
            },
          });

          travellers_created.push(traveller);

          // Process files for this traveller
          if (!passenger.files || passenger.files.length === 0) continue;
          
          for (const file of passenger.files) {
            // Try to match file to required document by name/type
            let matched_document = required_documents.find(doc => {
              const doc_name_lower = doc.document_name.toLowerCase();
              const file_type_lower = file.file_type.toLowerCase();
              const filename_lower = file.filename.toLowerCase();

              return doc_name_lower.includes(file_type_lower) ||
                     filename_lower.includes(doc_name_lower) ||
                     doc.document_code.toLowerCase().includes(file_type_lower);
            });

            // If no match found, use first required document or create a generic one
            if (!matched_document && required_documents.length > 0) {
              matched_document = required_documents[0];
            }

            if (matched_document) {
              // Upload file to S3
              const file_ext = path.extname(file.filename);
              const s3_key = `orders/${order.order_id}/travellers/${traveller.order_traveller_id}/${file.file_type}/${Date.now()}-${file.filename}`;
              
              let s3_url: string;
              try {
                // Determine content type
                const ext = file_ext.slice(1).toLowerCase();
                let content_type = 'application/octet-stream';
                if (['jpg', 'jpeg'].includes(ext)) content_type = 'image/jpeg';
                else if (ext === 'png') content_type = 'image/png';
                else if (ext === 'pdf') content_type = 'application/pdf';
                
                const upload_result = await upload_to_s3({
                  file_path: file.file_path,
                  s3_key: s3_key,
                  content_type: content_type,
                  metadata: {
                    order_id: order.order_id,
                    traveller_id: traveller.order_traveller_id,
                    document_type: file.file_type,
                    original_filename: file.filename,
                  },
                });
                s3_url = upload_result.s3_url;
              } catch (error) {
                logger.error(`Failed to upload file to S3: ${file.filename}`, error);
                throw new Error(`Failed to upload file to S3: ${error instanceof Error ? error.message : 'Unknown error'}`);
              }

              // Create document record
              const document = await tx.orderTravellerDocument.create({
                data: {
                  order_id: order.id,
                  traveller_id: traveller.id,
                  required_document_id: matched_document.id,
                  file_url: s3_url,
                  verification_status: null,
                  verification_notes: null,
                  verified_at: null,
                  ocr_status: 'PENDING',
                  ocr_job_id: null,
                  ocr_extracted_data: Prisma.JsonNull,
                },
              });
            }
          }
        }

        // Clean up temporary files
        if (input.order_type === 'GROUP' && passengers.length > 0) {
          await cleanup_temp_files(passengers);
        }

        // Clean up uploaded zip file
        if (input.zip_file_path) {
          await delete_file(input.zip_file_path);
        }

        // Get counts
        const travellers_count = await tx.orderTraveller.count({
          where: { order_id: order.id },
        });

        const documents_count = await tx.orderTravellerDocument.count({
          where: { order_id: order.id },
        });

        // Get country and visa type to return UUIDs in response
        const order_country = await tx.country.findUnique({
          where: { id: order.country_id },
          select: { country_id: true },
        });

        const order_visa_type = await tx.visaType.findUnique({
          where: { id: order.visa_type_id },
          select: { visa_type_id: true },
        });

        return {
          id: order.id,
          order_id: order.order_id,
          partner_id: order.partner_id,
          visa_type_id: order_visa_type?.visa_type_id || input.visa_type_id, // Return UUID visa_type_id
          country_id: order_country?.country_id || input.country_id, // Return UUID country_id
          order_type: order.order_type,
          status: order.status,
          group_name: order.group_name,
          travel_dates: order.travel_dates,
          total_fee_amount: order.total_fee_amount,
          fee_currency: order.fee_currency,
          travellers_count,
          documents_count,
          created_at: order.created_at,
        };
      });

      // Send documents to OCR microservice asynchronously (fire and forget)
      setImmediate(async () => {
        try {
          await this.send_documents_to_ocr_service(result.order_id);
        } catch (error) {
          logger.error(`Failed to send documents to OCR service for order ${result.order_id}:`, error);
        }
      });

      return result;
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      throw new Error(`Failed to create order: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Send documents to OCR microservice for processing
   */
  private async send_documents_to_ocr_service(order_id: string): Promise<void> {
    try {
      // Find order by order_id (business ID)
      const order = await prisma.order.findFirst({
        where: { order_id },
        select: { id: true },
      });

      if (!order) {
        logger.warn(`Order not found: ${order_id}`);
        return;
      }

      // Get all documents for this order
      const documents = await prisma.orderTravellerDocument.findMany({
        where: {
          order_id: order.id,
        },
        include: {
          traveller: {
            select: {
              order_traveller_id: true,
              full_name: true,
            },
          },
        },
      });

      if (documents.length === 0) {
        logger.warn(`No documents found for order ${order_id}`);
        return;
      }

      // Group documents by type and prepare payload
      // Need to get file_type from S3 key path or metadata
      const documents_payload = documents.map((doc) => {
        // Extract document type from S3 key path (format: orders/{order_id}/travellers/{traveller_id}/{document_type}/...)
        const s3_key = doc.file_url.replace(/^s3:\/\/[^\/]+\//, '').replace(/^https?:\/\/[^\/]+\//, '');
        const path_parts = s3_key.split('/');
        const doc_type_from_path = path_parts.length >= 4 ? path_parts[3] : 'other';
        
        return {
          traveller_id: doc.traveller?.order_traveller_id || '',
          traveller_name: doc.traveller?.full_name || '',
          document_id: doc.order_traveller_document_id,
          file_url: doc.file_url,
          document_type: this.determine_document_type(doc.file_url, doc_type_from_path),
        };
      });

      // Send to OCR microservice
      const ocr_service_url = env.ocr.service_url;
      const response = await fetch(`${ocr_service_url}/process/documents`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          order_id,
          documents: documents_payload,
        }),
      });

      if (!response.ok) {
        const error_text = await response.text();
        throw new Error(`OCR microservice error: ${response.status} - ${error_text}`);
      }

      logger.info(`Documents sent to OCR microservice for order ${order_id}`);
    } catch (error) {
      logger.error(`Failed to send documents to OCR service:`, error);
      throw error;
    }
  }

  /**
   * Determine document type from file URL or other metadata
   */
  private determine_document_type(file_url: string, file_type?: string): string {
    // Use file_type from zip extractor if available
    if (file_type) {
      return file_type;
    }
    
    const url_lower = file_url.toLowerCase();
    
    if (url_lower.includes('passport_front')) return 'passport_front';
    if (url_lower.includes('passport_back')) return 'passport_back';
    if (url_lower.includes('passport')) return 'passport';
    if (url_lower.includes('flight')) return 'flight';
    if (url_lower.includes('hotel')) return 'hotel';
    
    return 'other';
  }
}

export default new OrderService();

